#!/usr/bin/env python3
"""
NFT Tracer Backend - Main Application
Manages eBPF tracing sessions, correlates events by SKB, and exports session summaries
"""

import os
import sys
import json
import time
import threading
import socket
import platform
from datetime import datetime
from collections import defaultdict
from typing import Dict, List, Optional
from dataclasses import dataclass, asdict
from flask import Flask, request, jsonify, send_file
from flask_cors import CORS
import psutil

# BCC imports (will be loaded dynamically)
try:
    from bcc import BPF
    BCC_AVAILABLE = True
except ImportError:
    BCC_AVAILABLE = False
    print("WARNING: BCC not available. Install with: pip install bcc")

app = Flask(__name__)
CORS(app)

# Configuration
OUTPUT_DIR = "/home/sean/Downloads/nft-tracer-app/output"
BPF_PROGRAM_PATH = "/home/sean/Downloads/nft-tracer-app/backend/nft_tracer.bpf.c"

os.makedirs(OUTPUT_DIR, exist_ok=True)


# ============================================
# Data Models
# ============================================

@dataclass
class NFTEvent:
    """Represents a single NFT trace event"""
    timestamp: int
    cpu_id: int
    pid: int
    skb_addr: int
    chain_addr: int
    expr_addr: int
    regs_addr: int
    hook: int
    chain_depth: int
    trace_type: int
    pf: int
    verdict: int
    verdict_raw: int
    queue_num: int
    rule_seq: int
    has_queue_bypass: int
    protocol: int
    src_ip: int
    dst_ip: int
    src_port: int
    dst_port: int
    rule_handle: int
    comm: str
    
    @staticmethod
    def from_bpf_event(event):
        """Convert BPF event to NFTEvent"""
        return NFTEvent(
            timestamp=event.timestamp,
            cpu_id=event.cpu_id,
            pid=event.pid,
            skb_addr=event.skb_addr,
            chain_addr=event.chain_addr,
            expr_addr=event.expr_addr,
            regs_addr=event.regs_addr,
            hook=event.hook,
            chain_depth=event.chain_depth,
            trace_type=event.trace_type,
            pf=event.pf,
            verdict=event.verdict,
            verdict_raw=event.verdict_raw,
            queue_num=event.queue_num,
            rule_seq=event.rule_seq,
            has_queue_bypass=event.has_queue_bypass,
            protocol=event.protocol,
            src_ip=event.src_ip,
            dst_ip=event.dst_ip,
            src_port=event.src_port,
            dst_port=event.dst_port,
            rule_handle=event.rule_handle,
            comm=event.comm.decode('utf-8', errors='ignore')
        )


@dataclass
class SKBTrace:
    """Aggregated trace for a single SKB"""
    skb_addr: int
    first_seen: int
    last_seen: int
    events: List[Dict]
    final_verdict: Optional[int] = None
    final_verdict_str: Optional[str] = None
    hook: Optional[int] = None
    protocol: Optional[int] = None
    src_ip: Optional[str] = None
    dst_ip: Optional[str] = None
    src_port: Optional[int] = None
    dst_port: Optional[int] = None
    total_rules_evaluated: int = 0
    verdict_changes: int = 0
    
    def add_event(self, event: NFTEvent):
        """Add event and track verdict changes"""
        event_dict = {
            'timestamp': event.timestamp,
            'trace_type': self._trace_type_str(event.trace_type),
            'verdict': self._verdict_str(event.verdict),
            'verdict_code': event.verdict,
            'rule_seq': event.rule_seq,
            'rule_handle': event.rule_handle if event.rule_handle > 0 else None,
            'chain_depth': event.chain_depth,
            'cpu_id': event.cpu_id,
            'comm': event.comm
        }
        
        # Track verdict changes
        if len(self.events) > 0:
            last_verdict = self.events[-1].get('verdict_code')
            if last_verdict != event.verdict:
                self.verdict_changes += 1
        
        self.events.append(event_dict)
        self.last_seen = event.timestamp
        
        # Update metadata from first packet info event
        if event.protocol > 0 and self.protocol is None:
            self.protocol = event.protocol
            self.src_ip = self._format_ip(event.src_ip)
            self.dst_ip = self._format_ip(event.dst_ip)
            self.src_port = event.src_port if event.src_port > 0 else None
            self.dst_port = event.dst_port if event.dst_port > 0 else None
        
        if event.hook != 255 and self.hook is None:
            self.hook = event.hook
        
        # Update final verdict
        if event.trace_type == 0:  # Chain completion
            self.final_verdict = event.verdict
            self.final_verdict_str = self._verdict_str(event.verdict)
        
        if event.trace_type == 1:  # Rule evaluation
            self.total_rules_evaluated += 1
    
    @staticmethod
    def _verdict_str(verdict: int) -> str:
        """Convert verdict code to string"""
        verdicts = {
            0: "DROP",
            1: "ACCEPT",
            2: "STOLEN",
            3: "QUEUE",
            4: "REPEAT",
            5: "STOP",
            10: "CONTINUE",
            11: "RETURN",
            12: "JUMP",
            13: "GOTO",
            14: "BREAK",
            255: "UNKNOWN"
        }
        return verdicts.get(verdict, f"UNKNOWN_{verdict}")
    
    @staticmethod
    def _trace_type_str(trace_type: int) -> str:
        """Convert trace type to string"""
        types = {
            0: "chain_exit",
            1: "rule_eval",
            2: "hook_exit"
        }
        return types.get(trace_type, f"unknown_{trace_type}")
    
    @staticmethod
    def _format_ip(ip: int) -> Optional[str]:
        """Convert integer IP to string"""
        if ip == 0:
            return None
        return socket.inet_ntoa(ip.to_bytes(4, byteorder='little'))
    
    def to_summary(self) -> Dict:
        """Create condensed summary with only important events"""
        # Keep only verdict changes and final verdict
        important_events = []
        last_verdict = None
        
        for event in self.events:
            verdict = event['verdict_code']
            # Keep if verdict changed or it's the final event
            if verdict != last_verdict or event == self.events[-1]:
                important_events.append(event)
                last_verdict = verdict
        
        return {
            'skb_addr': hex(self.skb_addr),
            'first_seen': self.first_seen,
            'last_seen': self.last_seen,
            'duration_ns': self.last_seen - self.first_seen,
            'protocol': self.protocol,
            'src_ip': self.src_ip,
            'dst_ip': self.dst_ip,
            'src_port': self.src_port,
            'dst_port': self.dst_port,
            'hook': self.hook,
            'final_verdict': self.final_verdict_str,
            'total_rules_evaluated': self.total_rules_evaluated,
            'verdict_changes': self.verdict_changes,
            'important_events': important_events,
            'all_events_count': len(self.events)
        }


# ============================================
# Trace Session Manager
# ============================================

class TraceSession:
    """Manages a single trace session"""
    
    def __init__(self, session_id: str, pcap_filter: str = ""):
        self.session_id = session_id
        self.pcap_filter = pcap_filter
        self.start_time = datetime.now()
        self.end_time = None
        self.running = False
        self.bpf = None
        self.thread = None
        
        # SKB tracking
        self.skb_traces: Dict[int, SKBTrace] = {}
        self.completed_traces: List[SKBTrace] = []
        self.lock = threading.Lock()
        
        # Statistics
        self.total_events = 0
        self.events_per_second = 0
        self.last_stats_time = time.time()
        self.last_event_count = 0
        
        # Metadata
        self.hostname = socket.gethostname()
        self.kernel_version = platform.release()
        self.cpu_count = psutil.cpu_count()
    
    def start(self) -> bool:
        """Start BPF tracing"""
        if not BCC_AVAILABLE:
            return False
        
        try:
            # Load BPF program
            with open(BPF_PROGRAM_PATH, 'r') as f:
                bpf_code = f.read()
            
            self.bpf = BPF(text=bpf_code)
            
            # Attach probes
            self.bpf.attach_kprobe(event="nft_do_chain", fn_name="kprobe__nft_do_chain")
            self.bpf.attach_kretprobe(event="nft_do_chain", fn_name="kretprobe__nft_do_chain")
            self.bpf.attach_kprobe(event="nft_immediate_eval", fn_name="kprobe__nft_immediate_eval")
            self.bpf.attach_kretprobe(event="nf_hook_slow", fn_name="kretprobe__nf_hook_slow")
            
            # Open perf buffer
            self.bpf["events"].open_perf_buffer(self._handle_event)
            
            self.running = True
            
            # Start polling thread
            self.thread = threading.Thread(target=self._poll_events)
            self.thread.daemon = True
            self.thread.start()
            
            return True
            
        except Exception as e:
            print(f"Error starting trace: {e}")
            return False
    
    def stop(self) -> str:
        """Stop tracing and export results"""
        self.running = False
        self.end_time = datetime.now()
        
        if self.thread:
            self.thread.join(timeout=2.0)
        
        # Flush all remaining SKBs
        with self.lock:
            for skb_addr, trace in self.skb_traces.items():
                self.completed_traces.append(trace)
            self.skb_traces.clear()
        
        # Export to JSON
        output_path = self._export_json()
        
        # Cleanup BPF
        if self.bpf:
            try:
                self.bpf.cleanup()
            except:
                pass
        
        return output_path
    
    def _poll_events(self):
        """Poll BPF perf buffer"""
        while self.running:
            try:
                self.bpf.perf_buffer_poll(timeout=100)
            except Exception as e:
                print(f"Error polling events: {e}")
                break
    
    def _handle_event(self, cpu, data, size):
        """Handle incoming BPF event"""
        event = self.bpf["events"].event(data)
        nft_event = NFTEvent.from_bpf_event(event)
        
        with self.lock:
            self.total_events += 1
            
            # Update stats
            now = time.time()
            if now - self.last_stats_time >= 1.0:
                self.events_per_second = self.total_events - self.last_event_count
                self.last_event_count = self.total_events
                self.last_stats_time = now
            
            # Get or create SKB trace
            skb_addr = nft_event.skb_addr
            
            if skb_addr == 0:
                # Hook exit event without SKB info
                return
            
            if skb_addr not in self.skb_traces:
                self.skb_traces[skb_addr] = SKBTrace(
                    skb_addr=skb_addr,
                    first_seen=nft_event.timestamp,
                    last_seen=nft_event.timestamp,
                    events=[]
                )
            
            # Add event to trace
            trace = self.skb_traces[skb_addr]
            trace.add_event(nft_event)
            
            # Move to completed if we got final verdict (chain exit with DROP/ACCEPT)
            if nft_event.trace_type == 0:  # Chain exit
                if nft_event.verdict in [0, 1]:  # DROP or ACCEPT
                    self.completed_traces.append(trace)
                    del self.skb_traces[skb_addr]
    
    def _export_json(self) -> str:
        """Export session to JSON file"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"trace_{self.session_id}_{timestamp}.json"
        output_path = os.path.join(OUTPUT_DIR, filename)
        
        # Prepare summary
        summary = {
            'session': {
                'id': self.session_id,
                'pcap_filter': self.pcap_filter,
                'start_time': self.start_time.isoformat(),
                'end_time': self.end_time.isoformat() if self.end_time else None,
                'duration_seconds': (self.end_time - self.start_time).total_seconds() if self.end_time else 0,
                'hostname': self.hostname,
                'kernel_version': self.kernel_version,
                'cpu_count': self.cpu_count
            },
            'statistics': {
                'total_events': self.total_events,
                'total_skbs_traced': len(self.completed_traces),
                'packets_dropped': sum(1 for t in self.completed_traces if t.final_verdict == 0),
                'packets_accepted': sum(1 for t in self.completed_traces if t.final_verdict == 1),
                'avg_rules_per_packet': sum(t.total_rules_evaluated for t in self.completed_traces) / len(self.completed_traces) if self.completed_traces else 0
            },
            'traces': [trace.to_summary() for trace in self.completed_traces]
        }
        
        # Write to file
        with open(output_path, 'w') as f:
            json.dump(summary, f, indent=2)
        
        return output_path
    
    def get_stats(self) -> Dict:
        """Get current session statistics"""
        with self.lock:
            return {
                'session_id': self.session_id,
                'running': self.running,
                'total_events': self.total_events,
                'events_per_second': self.events_per_second,
                'active_skbs': len(self.skb_traces),
                'completed_skbs': len(self.completed_traces),
                'start_time': self.start_time.isoformat(),
                'uptime_seconds': (datetime.now() - self.start_time).total_seconds()
            }


# ============================================
# Session Manager
# ============================================

class SessionManager:
    """Manages all trace sessions"""
    
    def __init__(self):
        self.sessions: Dict[str, TraceSession] = {}
        self.lock = threading.Lock()
    
    def create_session(self, session_id: str, pcap_filter: str = "") -> bool:
        """Create and start a new trace session"""
        with self.lock:
            if session_id in self.sessions:
                return False
            
            session = TraceSession(session_id, pcap_filter)
            if session.start():
                self.sessions[session_id] = session
                return True
            return False
    
    def stop_session(self, session_id: str) -> Optional[str]:
        """Stop a session and return output file path"""
        with self.lock:
            if session_id not in self.sessions:
                return None
            
            session = self.sessions[session_id]
            output_path = session.stop()
            del self.sessions[session_id]
            return output_path
    
    def get_session_stats(self, session_id: str) -> Optional[Dict]:
        """Get statistics for a session"""
        with self.lock:
            if session_id not in self.sessions:
                return None
            return self.sessions[session_id].get_stats()
    
    def list_sessions(self) -> List[Dict]:
        """List all active sessions"""
        with self.lock:
            return [session.get_stats() for session in self.sessions.values()]


# Global session manager
session_manager = SessionManager()


# ============================================
# REST API Endpoints
# ============================================

@app.route('/api/health', methods=['GET'])
def health_check():
    """Health check endpoint"""
    return jsonify({
        'status': 'ok',
        'bcc_available': BCC_AVAILABLE,
        'timestamp': datetime.now().isoformat()
    })


@app.route('/api/sessions', methods=['GET'])
def list_sessions():
    """List all active sessions"""
    sessions = session_manager.list_sessions()
    return jsonify({
        'sessions': sessions,
        'count': len(sessions)
    })


@app.route('/api/sessions', methods=['POST'])
def create_session():
    """Create and start a new trace session"""
    data = request.json
    session_id = data.get('session_id', f"trace_{int(time.time())}")
    pcap_filter = data.get('pcap_filter', '')
    
    if not BCC_AVAILABLE:
        return jsonify({'error': 'BCC not available'}), 500
    
    success = session_manager.create_session(session_id, pcap_filter)
    
    if success:
        return jsonify({
            'status': 'started',
            'session_id': session_id
        }), 201
    else:
        return jsonify({'error': 'Failed to start session'}), 400


@app.route('/api/sessions/<session_id>', methods=['DELETE'])
def stop_session(session_id):
    """Stop a trace session"""
    output_path = session_manager.stop_session(session_id)
    
    if output_path:
        filename = os.path.basename(output_path)
        return jsonify({
            'status': 'stopped',
            'session_id': session_id,
            'output_file': filename
        })
    else:
        return jsonify({'error': 'Session not found'}), 404


@app.route('/api/sessions/<session_id>/stats', methods=['GET'])
def get_session_stats(session_id):
    """Get session statistics"""
    stats = session_manager.get_session_stats(session_id)
    
    if stats:
        return jsonify(stats)
    else:
        return jsonify({'error': 'Session not found'}), 404


@app.route('/api/download/<filename>', methods=['GET'])
def download_file(filename):
    """Download a trace result file"""
    file_path = os.path.join(OUTPUT_DIR, filename)
    
    if os.path.exists(file_path):
        return send_file(file_path, as_attachment=True)
    else:
        return jsonify({'error': 'File not found'}), 404


@app.route('/api/files', methods=['GET'])
def list_files():
    """List all available trace files"""
    files = []
    for filename in os.listdir(OUTPUT_DIR):
        if filename.endswith('.json'):
            filepath = os.path.join(OUTPUT_DIR, filename)
            stat = os.stat(filepath)
            files.append({
                'filename': filename,
                'size': stat.st_size,
                'created': datetime.fromtimestamp(stat.st_ctime).isoformat()
            })
    
    files.sort(key=lambda x: x['created'], reverse=True)
    return jsonify({'files': files})


# ============================================
# Main
# ============================================

if __name__ == '__main__':
    print("=" * 60)
    print("NFT Tracer Backend")
    print("=" * 60)
    print(f"BCC Available: {BCC_AVAILABLE}")
    print(f"Output Directory: {OUTPUT_DIR}")
    print(f"BPF Program: {BPF_PROGRAM_PATH}")
    print("=" * 60)
    
    # Run Flask app
    app.run(host='0.0.0.0', port=5000, debug=True, threaded=True)
